<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Only Up: Raycast Car</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: 'Segoe UI', sans-serif; }
        #hud {
            position: absolute; top: 20px; left: 20px; pointer-events: none;
            color: #0ff; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px; border: 1px solid #0ff;
        }
        #center-cross {
            position: absolute; top: 50%; left: 50%; width: 10px; height: 10px;
            border: 2px solid #0f0; border-radius: 50%; transform: translate(-50%, -50%);
            z-index: 10;
        }
        #winch-alert {
            position: absolute; bottom: 150px; width: 100%; text-align: center;
            color: yellow; font-size: 24px; font-weight: bold; display: none; text-shadow: 0 0 10px red;
        }
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center;
            flex-direction: column; color: white; cursor: pointer; z-index: 100;
        }
    </style>
</head>
<body>
    <div id="start-screen">
        <h1>ONLY UP: PHYSICS EDITION</h1>
        <p>Кликни чтобы начать</p>
        <p style="color:#aaa">WASD - Езда | SPACE - Тормоз | ЛКМ/ПКМ - Крюк | SHIFT - Тянуть лебедкой</p>
    </div>

    <div id="center-cross"></div>
    <div id="winch-alert">>>> ЛЕБЕДКА АКТИВНА <<<</div>
    
    <div id="hud">
        <div>Высота: <span id="h-val">0</span> м</div>
        <div>Скорость: <span id="s-val">0</span> км/ч</div>
    </div>

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- КОНФИГУРАЦИЯ ---
        const CFG = {
            gravity: -20,       // Гравитация (чуть меньше земной для фана)
            engineForce: 2000,  // Мощность мотора
            brakeForce: 100,    // Тормоз
            winchForce: 4000,   // Сила лебедки
            ropeStiffness: 0.1  // Жесткость веревки
        };

        // --- СЦЕНА ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111115);
        scene.fog = new THREE.Fog(0x111115, 30, 150);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Свет
        const ambi = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambi);
        const sun = new THREE.DirectionalLight(0xffffff, 1);
        sun.position.set(50, 100, 50);
        sun.castShadow = true;
        sun.shadow.camera.bottom = -50;
        sun.shadow.camera.top = 50;
        sun.shadow.camera.left = -50;
        sun.shadow.camera.right = 50;
        sun.shadow.mapSize.width = 2048; 
        sun.shadow.mapSize.height = 2048;
        scene.add(sun);

        // --- ФИЗИЧЕСКИЙ МИР ---
        const world = new CANNON.World();
        world.gravity.set(0, CFG.gravity, 0);
        world.broadphase = new CANNON.SAPBroadphase(world);

        const defaultMaterial = new CANNON.Material('default');
        const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
            friction: 0.3,
            restitution: 0.0, // Не прыгать
        });
        world.addContactMaterial(defaultContactMaterial);

        // --- СОЗДАНИЕ RAYCAST VEHICLE (Правильная машина) ---
        
        // 1. Кузов (Chassis)
        const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.5, 2));
        const chassisBody = new CANNON.Body({ mass: 150 });
        chassisBody.addShape(chassisShape, new CANNON.Vec3(0, 0.5, 0)); // Центр тяжести ниже геометрии
        chassisBody.position.set(0, 4, 0);
        chassisBody.angularDamping = 0.5;
        
        // Визуал кузова
        const chassisMesh = new THREE.Mesh(
            new THREE.BoxGeometry(2, 1, 4),
            new THREE.MeshStandardMaterial({ color: 0xff0055 })
        );
        chassisMesh.castShadow = true;
        scene.add(chassisMesh); // Синхронизируем позже
        world.addBody(chassisBody);

        // 2. Настройка машины
        const vehicle = new CANNON.RaycastVehicle({
            chassisBody: chassisBody,
        });

        const wheelOptions = {
            radius: 0.5,
            directionLocal: new CANNON.Vec3(0, -1, 0),
            suspensionStiffness: 30,
            suspensionRestLength: 0.3,
            frictionSlip: 1.4,
            dampingRelaxation: 2.3,
            dampingCompression: 4.4,
            maxSuspensionForce: 100000,
            rollInfluence: 0.01,
            axleLocal: new CANNON.Vec3(1, 0, 0),
            chassisConnectionPointLocal: new CANNON.Vec3(1, 1, 0),
            maxSuspensionTravel: 0.3,
            customSlidingRotationalSpeed: -30,
            useCustomSlidingRotationalSpeed: true
        };

        // Добавляем колеса
        // FL
        wheelOptions.chassisConnectionPointLocal.set(1, 0, 1.5);
        vehicle.addWheel(wheelOptions);
        // FR
        wheelOptions.chassisConnectionPointLocal.set(-1, 0, 1.5);
        vehicle.addWheel(wheelOptions);
        // RL
        wheelOptions.chassisConnectionPointLocal.set(1, 0, -1.5);
        vehicle.addWheel(wheelOptions);
        // RR
        wheelOptions.chassisConnectionPointLocal.set(-1, 0, -1.5);
        vehicle.addWheel(wheelOptions);

        vehicle.addToWorld(world);

        // 3. Визуал колес
        const wheelBodies = [];
        const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 20);
        wheelGeo.rotateZ(Math.PI/2);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        
        vehicle.wheelInfos.forEach((wheel) => {
            const wMesh = new THREE.Mesh(wheelGeo, wheelMat);
            wMesh.castShadow = true;
            scene.add(wMesh);
            wheelBodies.push(wMesh);
        });

        // --- УРОВЕНЬ (Voxel-Style Ramps) ---
        const levelObjects = []; // Для рейкаста

        function createStaticBox(x, y, z, w, h, d, color) {
            // Three
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(w, h, d),
                new THREE.MeshStandardMaterial({ color: color })
            );
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            levelObjects.push(mesh);

            // Cannon
            const shape = new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2));
            const body = new CANNON.Body({ mass: 0 }); // Статик
            body.addShape(shape);
            body.position.set(x, y, z);
            world.addBody(body);
        }

        // Стартовая площадка
        createStaticBox(0, -1, 0, 30, 2, 30, 0x444444);

        // Генерация пути
        let cx=0, cy=0, cz=-20;
        let dir = 0; // 0: -Z, 1: +X, 2: +Z, 3: -X

        for(let i=0; i<40; i++) {
            // Строим сегмент рампы (ступеньками для сцепления)
            const steps = 10;
            const width = 12;
            const length = 40;
            const height = 15;
            
            const stepLen = length / steps;
            const stepH = height / steps;
            
            // Направление смещения
            let dx=0, dz=0;
            if(dir === 0) dz = -1;
            else if(dir === 1) dx = 1;
            else if(dir === 2) dz = 1;
            else if(dir === 3) dx = -1;

            for(let s=0; s<steps; s++) {
                // Координаты ступени
                const sx = cx + dx * (s * stepLen + stepLen/2);
                const sz = cz + dz * (s * stepLen + stepLen/2);
                const sy = cy + s * stepH + stepH/2;

                // Размеры ступени (чуть перекрываемся чтобы не было щелей)
                const bw = (dir===1||dir===3) ? stepLen : width;
                const bd = (dir===1||dir===3) ? width : stepLen;

                createStaticBox(sx, sy, sz, bw, stepH, bd, i%2?0xaa4444:0x4444aa);
            }

            // Обновляем курсор
            cx += dx * length;
            cz += dz * length;
            cy += height;

            // Площадка отдыха
            const px = cx + dx*10; 
            const pz = cz + dz*10;
            createStaticBox(px, cy, pz, 20, 1, 20, 0x44aa44);
            
            cx = px + dx*10;
            cz = pz + dz*10;

            // Поворот
            if(Math.random() > 0.3) {
                const turn = Math.random() > 0.5 ? 1 : -1;
                dir = (dir + turn + 4) % 4;
            }
        }

        // --- УПРАВЛЕНИЕ ---
        const keys = { w:0, a:0, s:0, d:0, shift:0, space:0 };
        
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': keys.w = 1; break;
                case 'KeyS': keys.s = 1; break;
                case 'KeyA': keys.a = 1; break;
                case 'KeyD': keys.d = 1; break;
                case 'ShiftLeft': keys.shift = 1; break;
                case 'Space': keys.space = 1; break;
                case 'KeyR': 
                    chassisBody.position.set(0, 5, 0);
                    chassisBody.velocity.set(0,0,0);
                    chassisBody.angularVelocity.set(0,0,0);
                    chassisBody.quaternion.set(0,0,0,1);
                    break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': keys.w = 0; break;
                case 'KeyS': keys.s = 0; break;
                case 'KeyA': keys.a = 0; break;
                case 'KeyD': keys.d = 0; break;
                case 'ShiftLeft': keys.shift = 0; break;
                case 'Space': keys.space = 0; break;
            }
        });

        // Камера PointerLock
        const controls = new PointerLockControls(camera, document.body);
        const startDiv = document.getElementById('start-screen');
        startDiv.onclick = () => controls.lock();
        controls.addEventListener('lock', () => startDiv.style.display = 'none');
        controls.addEventListener('unlock', () => startDiv.style.display = 'flex');

        // --- КРЮКИ ---
        const raycaster = new THREE.Raycaster();
        const hooks = {
            f: { active: false, line: createLine(0x00ff00), point: new CANNON.Vec3() },
            b: { active: false, line: createLine(0xff00ff), point: new CANNON.Vec3() }
        };

        function createLine(c) {
            const l = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]),
                new THREE.LineBasicMaterial({ color: c, linewidth: 3 })
            );
            l.frustumCulled = false;
            scene.add(l);
            return l;
        }

        function fireHook(isFront) {
            if(!controls.isLocked) return;
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = raycaster.intersectObjects(levelObjects);
            if(hits.length > 0 && hits[0].distance < 150) {
                const h = isFront ? hooks.f : hooks.b;
                h.active = true;
                h.point.copy(hits[0].point);
            }
        }
        function releaseHook(isFront) {
            const h = isFront ? hooks.f : hooks.b;
            h.active = false;
            h.line.visible = false;
        }

        window.addEventListener('mousedown', e => {
            if(e.button === 0) fireHook(true);
            if(e.button === 2) fireHook(false);
        });
        window.addEventListener('mouseup', e => {
            if(e.button === 0) releaseHook(true);
            if(e.button === 2) releaseHook(false);
        });
        window.addEventListener('contextmenu', e=>e.preventDefault());


        // --- LOOP ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            if(!controls.isLocked) {
                renderer.render(scene, camera);
                return;
            }
            
            const dt = Math.min(clock.getDelta(), 0.1);

            // 1. Управление машиной (RAYCAST VEHICLE API)
            
            // Газ/Тормоз (Привод на задние колеса 2 и 3)
            let force = 0;
            if(keys.w) force = -CFG.engineForce; // Cannon использует минус для движения вперед
            if(keys.s) force = CFG.engineForce;
            
            vehicle.applyEngineForce(force, 2);
            vehicle.applyEngineForce(force, 3);

            // Руль (Передние колеса 0 и 1)
            let steer = 0;
            if(keys.a) steer = 0.5;
            if(keys.d) steer = -0.5;
            
            vehicle.setSteeringValue(steer, 0);
            vehicle.setSteeringValue(steer, 1);

            // Тормоз
            let brake = 0;
            if(keys.space) brake = 50;
            vehicle.setBrake(brake, 0);
            vehicle.setBrake(brake, 1);
            vehicle.setBrake(brake, 2);
            vehicle.setBrake(brake, 3);

            // 2. Стабилизация полета (Anti-Roll)
            // Если машина в воздухе, даем возможность крутиться
            if(chassisBody.position.y > 2) {
                // Если нажали Space в воздухе - выравниваем
                if(keys.space) {
                    const euler = new CANNON.Vec3();
                    chassisBody.quaternion.toEuler(euler);
                    // Плавно возвращаем к 0 по X и Z
                    chassisBody.angularVelocity.set(
                        chassisBody.angularVelocity.x * 0.9,
                        chassisBody.angularVelocity.y,
                        chassisBody.angularVelocity.z * 0.9
                    );
                }
            }

            // 3. Крюки
            const isPulling = keys.shift;
            document.getElementById('winch-alert').style.display = isPulling && (hooks.f.active || hooks.b.active) ? 'block' : 'none';

            [hooks.f, hooks.b].forEach((h, i) => {
                if(h.active) {
                    h.line.visible = true;
                    // Точка на корпусе
                    const localAnchor = new CANNON.Vec3(0, 0.5, i===0 ? 2 : -2); // Перед/Зад
                    const worldAnchor = new CANNON.Vec3();
                    chassisBody.pointToWorldFrame(localAnchor, worldAnchor);

                    // Вектор к цели
                    const dir = h.point.vsub(worldAnchor);
                    const dist = dir.length();
                    dir.normalize();

                    // Сила
                    let f = 0;
                    if(isPulling) {
                         // Лебедка: тянет сильно
                         f = CFG.winchForce;
                    } else {
                        // Просто веревка: тянет только если натянута (пружина)
                        // Упростим: просто небольшая сила чтобы трос не висел
                        if(dist > 5) f = 100; 
                    }

                    // Прикладываем силу к точке крепления
                    chassisBody.applyForce(dir.scale(f), worldAnchor);

                    // Отрисовка
                    const p = h.line.geometry.attributes.position.array;
                    p[0]=worldAnchor.x; p[1]=worldAnchor.y; p[2]=worldAnchor.z;
                    p[3]=h.point.x; p[4]=h.point.y; p[5]=h.point.z;
                    h.line.geometry.attributes.position.needsUpdate = true;
                }
            });

            // 4. Физика Шаг
            world.step(1/60, dt, 10);

            // 5. Синхронизация визуализации
            // Кузов
            chassisMesh.position.copy(chassisBody.position);
            chassisMesh.quaternion.copy(chassisBody.quaternion);
            
            // Колеса
            for(let i=0; i<vehicle.wheelInfos.length; i++) {
                vehicle.updateWheelTransform(i);
                const t = vehicle.wheelInfos[i].worldTransform;
                wheelBodies[i].position.copy(t.position);
                wheelBodies[i].quaternion.copy(t.quaternion);
            }

            // 6. Камера (Следует за машиной + Мышь вращает)
            const lookDir = new THREE.Vector3();
            camera.getWorldDirection(lookDir);
            
            const targetPos = chassisMesh.position.clone().add(new THREE.Vector3(0, 3, 0));
            // Камера всегда "сзади" относительно взгляда игрока
            const camPos = targetPos.clone().sub(lookDir.clone().normalize().multiplyScalar(10));
            
            // Не даем камере уйти под землю (упрощенно)
            if(camPos.y < targetPos.y - 2) camPos.y = targetPos.y - 2;

            camera.position.copy(camPos);

            // UI
            document.getElementById('h-val').innerText = Math.round(chassisBody.position.y);
            const kmh = Math.round(chassisBody.velocity.length() * 3.6);
            document.getElementById('s-val').innerText = kmh;

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
